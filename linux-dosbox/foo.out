Start parsing!
Opening the global scope...
 ---> A scope has been opened
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
 ---> A scope has been opened
 <--- A scope has been closed
this function 'foo' is a new one
 ---> A scope has been opened
 ---> A scope has been opened
I just looked up lvalue 'msg' and found it @ 8
WRITE, TYPE_array, STRING
Write call is 4 quad len
I just looked up lvalue 'n' and found it @ 10
I just looked up lvalue 'i' and found it @ -2
	after init, quads = 2
	after check, quads = 7
 ---> A scope has been opened
I just looked up lvalue 'i' and found it @ -2
conversion of expression to condition is 7 quads long
Write call is 2 quad len
if-then->cond is 7 quad long
if-then->stmt is 2 quad long
if-then is 9 quad long
I just looked up lvalue 'i' and found it @ -2
I just looked up lvalue 'x' and found it @ 12
Write call is 4 quad len
 <--- A scope has been closed
for->stmt is 13 quads long
Write call is 2 quad len
Will close Scope so this is ST:

----------------------------------------
$3 int[-7], $2 bool[-5], $1 int[-4], i int[-2], [eos]
	son of:
msg char[][8], n int[10], x int[][12], [eos]
	son of:
foo (reference x : int[], n : int, reference msg : char[], [eop]) : PROC with size : 12, new , strcat , strcpy , strcmp , strlen , ROUND , TRUNC , round , trunc , tan , sqrt , sin , pi , ln , fabs , exp , cos , arctan , abs , READ_STRING , READ_REAL , getchar , READ_BOOL , READ_INT , WRITE_STRING , WRITE_REAL , WRITE_CHAR , WRITE_BOOL , WRITE_INT , puts , putchar , writeString , writeReal , writeBoolean , writeChar , writeInteger , [eos]
	son of:
[eos]
	son of:
GlobalScope of the House Compilers
----------------------------------------

 <--- A scope has been closed
 <--- A scope has been closed
this function 'print' is a new one
 ---> A scope has been opened
 ---> A scope has been opened
I just looked up lvalue 'msg' and found it @ 12
WRITE, TYPE_array, STRING
Write call is 2 quad len
I just looked up lvalue 'n' and found it @ 10
I just looked up lvalue 'i' and found it @ -2
	after init, quads = 2
	after check, quads = 7
 ---> A scope has been opened
I just looked up lvalue 'i' and found it @ -2
conversion of expression to condition is 7 quads long
Write call is 2 quad len
if-then->cond is 7 quad long
if-then->stmt is 2 quad long
if-then is 9 quad long
I just looked up lvalue 'i' and found it @ -2
I just looked up lvalue 'x' and found it @ 8
Write call is 4 quad len
 <--- A scope has been closed
for->stmt is 13 quads long
Write call is 2 quad len
Will close Scope so this is ST:

----------------------------------------
$9 int[-7], $8 bool[-5], $7 int[-4], i int[-2], [eos]
	son of:
x int[][8], n int[10], msg char[][12], [eos]
	son of:
print (reference msg : char[], n : int, reference x : int[], [eop]) : PROC with size : 12, foo (reference x : int[], n : int, reference msg : char[], [eop]) : PROC with size : 12, new , strcat , strcpy , strcmp , strlen , ROUND , TRUNC , round , trunc , tan , sqrt , sin , pi , ln , fabs , exp , cos , arctan , abs , READ_STRING , READ_REAL , getchar , READ_BOOL , READ_INT , WRITE_STRING , WRITE_REAL , WRITE_CHAR , WRITE_BOOL , WRITE_INT , puts , putchar , writeString , writeReal , writeBoolean , writeChar , writeInteger , [eos]
	son of:
[eos]
	son of:
GlobalScope of the House Compilers
----------------------------------------

 <--- A scope has been closed
 <--- A scope has been closed
this function 'bar' is a new one
 ---> A scope has been opened
I just looked up lvalue 'i' and found it @ -4
	after init, quads = 1
	after check, quads = 7
 ---> A scope has been opened
I just looked up lvalue 'seed' and found it @ -2
I just looked up lvalue 'seed' and found it @ -2
I just looked up lvalue 'i' and found it @ -4
I just looked up lvalue 'i' and found it @ -4
I just looked up lvalue 'x' and found it @ -36
I just looked up lvalue 'seed' and found it @ -2
I just looked up lvalue 'i' and found it @ -4
conversion of expression to condition is 7 quads long
Write call is 2 quad len
if-then->cond is 7 quad long
if-then->stmt is 2 quad long
if-then is 9 quad long
I just looked up lvalue 'i' and found it @ -4
I just looked up lvalue 'x' and found it @ -36
Write call is 4 quad len
 <--- A scope has been closed
for->stmt is 21 quads long
Write call is 2 quad len
I just looked up lvalue 'x' and found it @ -36
Call is 4 long
Will close Scope so this is ST:

----------------------------------------
$14 int[-39], $13 bool[-37], x int[16][-36], i int[-4], seed int[-2], [eos]
	son of:
bar ([eop]) : PROC with size : 56, print (reference msg : char[], n : int, reference x : int[], [eop]) : PROC with size : 12, foo (reference x : int[], n : int, reference msg : char[], [eop]) : PROC with size : 12, new , strcat , strcpy , strcmp , strlen , ROUND , TRUNC , round , trunc , tan , sqrt , sin , pi , ln , fabs , exp , cos , arctan , abs , READ_STRING , READ_REAL , getchar , READ_BOOL , READ_INT , WRITE_STRING , WRITE_REAL , WRITE_CHAR , WRITE_BOOL , WRITE_INT , puts , putchar , writeString , writeReal , writeBoolean , writeChar , writeInteger , [eos]
	son of:
[eos]
	son of:
GlobalScope of the House Compilers
----------------------------------------

 <--- A scope has been closed
Close the global scope...
 <--- A scope has been closed
End parsing!
Intermediate code:
  1: unit, foo, --, --
  2: par, msg, R, --
  3: call, --, --, writeString
  4: par, '\n', V, --
  5: call, --, --, writeChar
  6: -, n, 1, $1
  7: :=, 0, --, i
  8: <=, i, $1, 10
  9: jump, --, --, 12
 10: :=, true, --, $2
 11: jump, --, --, 13
 12: :=, false, --, $2
 13: ifb, $2, --, 15
 14: jump, --, --, 31
 15: >, i, 0, 17
 16: jump, --, --, 19
 17: :=, true, --, $4
 18: jump, --, --, 20
 19: :=, false, --, $4
 20: ifb, $4, --, 22
 21: jump, --, --, 24
 22: par, ", ", R, --
 23: call, --, --, writeString
 24: *, i, 2, $6
 25: array, x, $6, $5
 26: par, [$5], V, --
 27: call, --, --, writeInteger
 28: +, i, 1, $3
 29: :=, $3, --, i
 30: jump, --, --, 8
 31: par, '\n', V, --
 32: call, --, --, writeChar
 33: ret, --, --, --
 34: endu, foo, --, --
 35: unit, print, --, --
 36: par, msg, R, --
 37: call, --, --, writeString
 38: -, n, 1, $7
 39: :=, 0, --, i
 40: <=, i, $7, 42
 41: jump, --, --, 44
 42: :=, true, --, $8
 43: jump, --, --, 45
 44: :=, false, --, $8
 45: ifb, $8, --, 47
 46: jump, --, --, 63
 47: >, i, 0, 49
 48: jump, --, --, 51
 49: :=, true, --, $10
 50: jump, --, --, 52
 51: :=, false, --, $10
 52: ifb, $10, --, 54
 53: jump, --, --, 56
 54: par, ", ", R, --
 55: call, --, --, writeString
 56: *, i, 2, $12
 57: array, x, $12, $11
 58: par, [$11], V, --
 59: call, --, --, writeInteger
 60: +, i, 1, $9
 61: :=, $9, --, i
 62: jump, --, --, 40
 63: par, '\n', V, --
 64: call, --, --, writeChar
 65: ret, --, --, --
 66: endu, print, --, --
 67: unit, bar, --, --
 68: :=, 65, --, seed
 69: :=, 0, --, i
 70: <=, i, 15, 72
 71: jump, --, --, 74
 72: :=, true, --, $13
 73: jump, --, --, 75
 74: :=, false, --, $13
 75: ifb, $13, --, 77
 76: jump, --, --, 101
 77: *, seed, 137, $15
 78: +, $15, 221, $16
 79: +, $16, i, $17
 80: %, $17, 101, $18
 81: :=, $18, --, seed
 82: *, i, 2, $20
 83: array, x, $20, $19
 84: :=, seed, --, [$19]
 85: >, i, 0, 87
 86: jump, --, --, 89
 87: :=, true, --, $21
 88: jump, --, --, 90
 89: :=, false, --, $21
 90: ifb, $21, --, 92
 91: jump, --, --, 94
 92: par, ", ", R, --
 93: call, --, --, writeString
 94: *, i, 2, $23
 95: array, x, $23, $22
 96: par, [$22], V, --
 97: call, --, --, writeInteger
 98: +, i, 1, $14
 99: :=, $14, --, i
100: jump, --, --, 70
101: par, '\n', V, --
102: call, --, --, writeChar
103: par, x, R, --
104: par, 16, V, --
105: par, "hello", R, --
106: call, --, --, foo
107: ret, --, --, --
108: endu, bar, --, --

; x86 assembly - intel syntax
xseg	segment	public 'code'
	assume	cs:xseg, ds:xseg, ss:xseg
	org	100h
main	proc	near
	call	near ptr _bar_3
	mov	ax,4C00h
	int	21h
main	endp
@str1 db ", "
	db 0
@str2 db ", "
	db 0
@str3 db ", "
	db 0
@str4 db "hello"
	db 0
@1:
_foo_1	proc near
	push bp
	mov bp, sp
	sub sp, 12
@2:
	mov si, word ptr [bp + 8]
	push si
@3:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeString
	add sp, 4
@4:
	mov al, 10
	sub sp, 1
	mov si, sp
	mov byte ptr [si], al
@5:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeChar
	add sp, 5
@6:
	mov ax, word ptr [bp + 10]
	mov dx, 1
	sub ax, dx
	mov word ptr [bp - 4], ax
@7:
	mov ax, 0
	mov word ptr [bp - 2], ax
@8:
	mov ax, word ptr [bp - 2]
	mov dx, word ptr [bp - 4]
	cmp ax, dx
	jle @10
@9:
	jmp @12
@10:
	mov al, 1
	mov byte ptr [bp - 5], al
@11:
	jmp @13
@12:
	mov al, 0
	mov byte ptr [bp - 5], al
@13:
	mov al, byte ptr [bp - 5]
	or al, al
	jnz @15
@14:
	jmp @31
@15:
	mov ax, word ptr [bp - 2]
	mov dx, 0
	cmp ax, dx
	jg @17
@16:
	jmp @19
@17:
	mov al, 1
	mov byte ptr [bp - 8], al
@18:
	jmp @20
@19:
	mov al, 0
	mov byte ptr [bp - 8], al
@20:
	mov al, byte ptr [bp - 8]
	or al, al
	jnz @22
@21:
	jmp @24
@22:
	lea si, byte ptr @str1
	push si
@23:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeString
	add sp, 4
@24:
	mov ax, word ptr [bp - 2]
	mov cx, 2
	imul cx
	mov word ptr [bp - 12], ax
@25:
	mov ax, word ptr [bp - 12]
	mov cx, word
	imul cx
	mov cx, word ptr [bp + 12]
	add ax, cx
	mov word ptr [bp - 10], ax
@26:
	mov di, word ptr [bp - 10]
	mov ax, word ptr [di]
	push ax
@27:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeInteger
	add sp, 6
@28:
	mov ax, word ptr [bp - 2]
	mov dx, 1
	add ax, dx
	mov word ptr [bp - 7], ax
@29:
	mov ax, word ptr [bp - 7]
	mov word ptr [bp - 2], ax
@30:
	jmp @8
@31:
	mov al, 10
	sub sp, 1
	mov si, sp
	mov byte ptr [si], al
@32:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeChar
	add sp, 5
@33:
	jmp @foo_1
@34:
@foo_1:
	mov sp, bp
	pop bp
	ret
_foo_1	endp
@35:
_print_2	proc near
	push bp
	mov bp, sp
	sub sp, 12
@36:
	mov si, word ptr [bp + 12]
	push si
@37:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeString
	add sp, 4
@38:
	mov ax, word ptr [bp + 10]
	mov dx, 1
	sub ax, dx
	mov word ptr [bp - 4], ax
@39:
	mov ax, 0
	mov word ptr [bp - 2], ax
@40:
	mov ax, word ptr [bp - 2]
	mov dx, word ptr [bp - 4]
	cmp ax, dx
	jle @42
@41:
	jmp @44
@42:
	mov al, 1
	mov byte ptr [bp - 5], al
@43:
	jmp @45
@44:
	mov al, 0
	mov byte ptr [bp - 5], al
@45:
	mov al, byte ptr [bp - 5]
	or al, al
	jnz @47
@46:
	jmp @63
@47:
	mov ax, word ptr [bp - 2]
	mov dx, 0
	cmp ax, dx
	jg @49
@48:
	jmp @51
@49:
	mov al, 1
	mov byte ptr [bp - 8], al
@50:
	jmp @52
@51:
	mov al, 0
	mov byte ptr [bp - 8], al
@52:
	mov al, byte ptr [bp - 8]
	or al, al
	jnz @54
@53:
	jmp @56
@54:
	lea si, byte ptr @str2
	push si
@55:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeString
	add sp, 4
@56:
	mov ax, word ptr [bp - 2]
	mov cx, 2
	imul cx
	mov word ptr [bp - 12], ax
@57:
	mov ax, word ptr [bp - 12]
	mov cx, word
	imul cx
	mov cx, word ptr [bp + 8]
	add ax, cx
	mov word ptr [bp - 10], ax
@58:
	mov di, word ptr [bp - 10]
	mov ax, word ptr [di]
	push ax
@59:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeInteger
	add sp, 6
@60:
	mov ax, word ptr [bp - 2]
	mov dx, 1
	add ax, dx
	mov word ptr [bp - 7], ax
@61:
	mov ax, word ptr [bp - 7]
	mov word ptr [bp - 2], ax
@62:
	jmp @40
@63:
	mov al, 10
	sub sp, 1
	mov si, sp
	mov byte ptr [si], al
@64:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeChar
	add sp, 5
@65:
	jmp @print_2
@66:
@print_2:
	mov sp, bp
	pop bp
	ret
_print_2	endp
@67:
_bar_3	proc near
	push bp
	mov bp, sp
	sub sp, 56
@68:
	mov ax, 65
	mov word ptr [bp - 2], ax
@69:
	mov ax, 0
	mov word ptr [bp - 4], ax
@70:
	mov ax, word ptr [bp - 4]
	mov dx, 15
	cmp ax, dx
	jle @72
@71:
	jmp @74
@72:
	mov al, 1
	mov byte ptr [bp - 37], al
@73:
	jmp @75
@74:
	mov al, 0
	mov byte ptr [bp - 37], al
@75:
	mov al, byte ptr [bp - 37]
	or al, al
	jnz @77
@76:
	jmp @101
@77:
	mov ax, word ptr [bp - 2]
	mov cx, 137
	imul cx
	mov word ptr [bp - 41], ax
@78:
	mov ax, word ptr [bp - 41]
	mov dx, 221
	add ax, dx
	mov word ptr [bp - 43], ax
@79:
	mov ax, word ptr [bp - 43]
	mov dx, word ptr [bp - 4]
	add ax, dx
	mov word ptr [bp - 45], ax
@80:
	mov ax, word ptr [bp - 45]
	cwd
	mov cx, 101
	idiv cx
	mov word ptr [bp - 47], dx
@81:
	mov ax, word ptr [bp - 47]
	mov word ptr [bp - 2], ax
@82:
	mov ax, word ptr [bp - 4]
	mov cx, 2
	imul cx
	mov word ptr [bp - 51], ax
@83:
	mov ax, word ptr [bp - 51]
	mov cx, word
	imul cx
	mov cx, word ptr [bp - 36]
	add ax, cx
	mov word ptr [bp - 49], ax
@84:
	mov ax, word ptr [bp - 2]
	mov di, word ptr [bp - 49]
	mov word ptr [di], ax
@85:
	mov ax, word ptr [bp - 4]
	mov dx, 0
	cmp ax, dx
	jg @87
@86:
	jmp @89
@87:
	mov al, 1
	mov byte ptr [bp - 52], al
@88:
	jmp @90
@89:
	mov al, 0
	mov byte ptr [bp - 52], al
@90:
	mov al, byte ptr [bp - 52]
	or al, al
	jnz @92
@91:
	jmp @94
@92:
	lea si, byte ptr @str3
	push si
@93:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeString
	add sp, 4
@94:
	mov ax, word ptr [bp - 4]
	mov cx, 2
	imul cx
	mov word ptr [bp - 56], ax
@95:
	mov ax, word ptr [bp - 56]
	mov cx, word
	imul cx
	mov cx, word ptr [bp - 36]
	add ax, cx
	mov word ptr [bp - 54], ax
@96:
	mov di, word ptr [bp - 54]
	mov ax, word ptr [di]
	push ax
@97:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeInteger
	add sp, 6
@98:
	mov ax, word ptr [bp - 4]
	mov dx, 1
	add ax, dx
	mov word ptr [bp - 39], ax
@99:
	mov ax, word ptr [bp - 39]
	mov word ptr [bp - 4], ax
@100:
	jmp @70
@101:
	mov al, 10
	sub sp, 1
	mov si, sp
	mov byte ptr [si], al
@102:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _writeChar
	add sp, 5
@103:
	mov si, word ptr [bp - 36]
	push si
@104:
	mov ax, 16
	push ax
@105:
	lea si, byte ptr @str4
	push si
@106:
	sub sp, 2
	push word ptr [bp + 4]
	call near ptr _foo_1
	add sp, 6
@107:
	jmp @bar_3
@108:
@bar_3:
	mov sp, bp
	pop bp
	ret
_bar_3	endp


 extrn __new : proc
 extrn __dispose : proc
 extrn _formatInteger : proc
 extrn _formatReal : proc
 extrn _parseInteger : proc
 extrn _parseReal : proc
 
 extrn _abs : proc
 extrn _arctan : proc
 extrn _cos : proc
 extrn _exp : proc
 extrn _fabs : proc
 extrn _ln : proc
 extrn _pi : proc
 extrn _sin : proc
 extrn _sqrt : proc
 extrn _tan : proc
 
 extrn _writeBoolean : proc
 extrn _writeChar : proc
 extrn _writeInteger : proc
 extrn _writeReal : proc
 extrn _writeString : proc
 extrn _readBoolean : proc
 extrn _readChar : proc
 extrn _readInteger : proc
 extrn _readReal : proc
 extrn _readString : proc
 
 extrn _chr : proc
 extrn _exit : proc
 extrn _ord : proc
 extrn _round : proc
 extrn _trunc : proc
 
xseg	ends
	end	main

